This documents the entire .h3m binary file format based on:

  1. https://github.com/potmdehex/homm3tools
     Commit 5687f581a4eb5e7b0e8f48794d7be4e3b0a8cc8b (2019)
     Parsing code belongs to h3m\h3mlib\, in particular to:
     h3m_constants\*, h3m_parsing\*, h3m_structures\*, internal\*, utils\*

  2. h3m_description.english.txt of the same repository and commit

  3. h3m.txt (Google + Yandex Translate) of the same repository and commit
     That file has numerous incoherences so h3mlib data was prioritized

  4. Original trial & error on h3maped.exe and Heroes3.exe (both v3.0.0.0, SoD)

HotA support is mainly based on FreeHeroes code (MIT), including:

  5. https://github.com/mapron/FreeHeroes
     Commit 7585701759973d8d8e003cfca7d2f609713c82a5 (2023)
     Parsing code belongs to src\Core\MapUtil\, in particular to H3MObjects.cpp

  6. Insights about the format from FH's author (Smirnov Vladimir @mapron):
     https://github.com/HeroWO-js/h3m2json/issues/1

  7. Original trial & error on HotA v1.6.1.

All strings are Pascal-type (leading length uint32), ASCII (locale-dependent).

Virtually all numbers are unsigned Little-Endian, with few exceptions.

Prior to parsing an .h3m file, run standard Zlib _inflate() on its entire
contents (PHP equivalent: gzdecode()). 7-Zip also works.

Last 4 bytes of the compressed stream (.h3m file) hold original stream's size.

This document was produced by the HeroWO.js project for the H3M convertor
implementation (h3m2herowo.php). Keep this file and that script in sync when
making changes to one of them.

This file is licensed under public domain/Unlicense.

------------------------------  .h3m: The Corpus  ------------------------------

[uint32] format       parse_h3m.c, h3m_format.h
  RoE 0x0E, AB 0x15, SoD 0x1C, CHR(?) 0x1D, WoG 0x33      h3m_format.h
  HotA1 0x1E, HotA2 0x1F, HotA3 0x20, VCMI 0xF0     H3MObjects.hpp
  GZIP magic is uint16 1F 8B (0x8B1F; inflate(), inflate.c:664)
[uint32] hota format1 (only seen 1 and 3 in the wild)  #only if HotA*
[uint16] hota format2 (only seen 0 in the wild)   #only if HotA*
[uint32] hota format3 (only seen 12 in the wild)  #only if HotAv3
  here and below, "HotAv3" means "HotA3 and format1 >= 3"; in FH, it's "HotA* and format1 >= 3" but it's likely a mistake
[...] basic info      parse_bi.c, h3m_bi.h
  [uint8] is playable (possibly not used in some cases/maps; called has_hero in h3mlib)
    at least two cases are known to clear this flag: 1) having no heroes and towns on map (independent of visiting heroes and "Generate hero at main town") and 2) having less than (11*count-1) Heroes checked in Map Specifications ("-1" because of the "Lord Haart" bug, see below; actually set bits in the available heroes field may be fewer than that due to hero objects on map)
    it seems that when this is set, SoD's map selection menu shows "This map is not playable" in place of map description; if there are no heroes/towns, the menu shows such map without players and attempt to start it gives an error; in other cases you can still start the game
  [uint32] map_size (width and height, square; 36 small, 72 medium, 108 large, 144 extra large; unknown when introduced exactly, assuming HotA*: 180 huge, 216 extra huge, 252 giant)
  [uint8] has_two_levels (0 single level, 1 has underground)
  [uint32] name_size (editor limits to 30)
  [...] name
  [uint32] desc_size
  [...] desc
  [uint8] difficulty (0 easy, 1 normal, 2 hard, 3 expert, 4 impossible)
  [uint8] hero mastery level cap   #only if AB/SoD
    editor's Map Specifications | General | Limit hero experience level to (affects all heroes - of humans and AI)
[...] players         parse_players.c, h3m_player.h
  N identical structures, one per player, N = 8, in order: red, blue, tan, green, orange, purple, teal, pink
      this is apparently meant for Advanced Options when starting the game; many fields here duplicate map objects' (probably so that reading full map is not required to obtain them)
    [uint8] can_be_human (if this and can_be_computer == 0 then player cannot be played and other structure properties are junk)
    [uint8] can_be_computer
    [uint8] behavior (0 random, 1 warrior, 2 builder, 3 explorer)
    [uint8] customized alignments (often contains junk when (!human and !computer))    #only if SoD
    [uint8] town_types (bitfield: Castle, Rampart, Tower, Inferno, Necropolis, Dungeon, Stronghold, Fortress; Complete: 8 Conflux; HotA*: 9 Cove)
    [uint8] town_conflux (bitfield with 1 LSB bit)    #only if AB/SOD
    [uint8] random town (if <> 0, implies all town types are enabled; unlike other bool fields, this often uses junk (>01) for TRUE)
      customized alignments is controlled by editor's Map Spec | Player Spec | Allowed alignments | "Customize" checkbox
      the 4 fields above are related; if customized is off, random is off and either only player's towns' types are set or all types (if owns no towns on map)
      enabled random town doesn't limit the player to choosing only "random" when starting the game - he may choose any town type, in addition to "random"
      customized and random fields can be ignored since town types are always set properly
    [uint8] has_main_town
    [...] if has_main_town == 0 and 2nd byte below == 0xFF
      [uint8] starting_hero_is_random
        here and below, starting hero fields simply reflect the hero object's, which is chosen by an unknown algorithm (perhaps this: first non-random non-placeholder hero owned by player, else first non-placeholder, else first placeholder, else a to-be generated by starting town if any, else none)
        the starting hero random field is separate (if map has 2 heroes: one normal, one random, then random is set and type/face/name are taken from normal hero)
        overall, it seems best to ignore starting hero fields (except random) as they're often misleading, e.g. if player has no hero objects but has GH enabled then random = false, type = 0xFF, face = 0, name = ""
        hero creation is affected by multiple variables, on which my research follows; to summarize: GH (as one'd expect) inserts a new hero object after other objects; Advanced Options customizes the first random hero (or shows "None"); game start replaces first random hero with the picked choice and all others with random heroes of the player's alignment
        on a related note, placeholder heroes that cannot be initialized (in non-campaign mode) are simply removed and if a map has no towns and just one hero (a placeholder) then starting it will have that player own nothing
        (RH) random hero presence (I tested with hero placed on map but I
             assume a hero created via Visiting works the same)
        (NRH) non-random hero presence (yy = yes, with customized name;
              same note as in RH above)
        (GH) state of "Generate hero at main town"
        (HS) hero selector state in Advanced Options of new game
             (y = can choose, n = only allows "none")
        (HN) hero name displayed under HS (* = hero's default name,
             n = Customize'd name given to hero object on map, likely a glitch
             since it doesn't reflect actual name that the new hero would have)
        (HG) actually generated hero(es) after game start
        | RH | NRH | GH || HS | HN | HG
        | n  | n   | n  || n† |    | 0 no new hero created
        | n  | n   | y  || y  | *  | 1 placed in starting town according to HS
        | n  | y   | n  || n‡ |    | = 0, NRH untouched
        | n  | yy  | n  || n‡ |    | = 0, NRH untouched
        | n  | y   | y  || y  | *  | = 1
        | n  | yy  | y  || y  | n  | = 1, hero's default name assigned
        † SoD glitch: if player has a town with Visiting hero, Advanced
          Options display ST = Random, SH = Random; ST = (other), SH = None,
          yet no hero is created even if ST is chosen Random (as expected)
        ‡ same glitch as above but happens even if there is no Visiting hero
        | y  | n   | n  || y  | *  | 2 RH replaced with hero according to HS
        | y  | n   | y  || y  | *  | = 2 + new random town-aligned hero put in ST
        | y  | y   | n  || y  | *  | = 2
        | y  | yy  | n  || y  | n  | = 2, hero's default name assigned
        | y  | y   | y  || y  | *  | = 2 + new random town-aligned hero put in ST
        | y  | yy  | y  || y  | n  | = 2, default name + new town-aligned in ST
      [uint8] starting_hero_type (always 0xFF)
      [uint8] starting_hero_face (0xFF for default face)
      [uint32] starting_hero_name_size (0 for default name)
      [...] starting_hero_name
    [...] if has_main_town <> 0 and 7th byte below == 0xFF
      [uint8] starting_town_create_hero ("Generate hero at main town" - forced on in RoE, or off if that town has a Visiting hero)   #only if AB/SoD
        here and below, starting town fields simply reflect the town object's
        a random town may be made Starting but its alignment doesn't necessary match the player's (editor's Town Properties | Alignment list); if so, and if "Generate hero at main town" is checked, the new hero's alignment will match the player's (picked when starting game) and may differ from the town's alignment
      [uint8] starting_town_type (0xFF random, others = order in town_types)          #only if AB/SoD
      [uint8] starting_town_xpos
      [uint8] starting_town_ypos
      [uint8] starting_town_zpos
      [uint8] starting_hero_is_random
      [uint8] starting_hero_type (always 0xFF)
      [uint8] starting_hero_face (0xFF for default)
      [uint32] starting_hero_name_size (0 for default)
      [...] starting_hero_name
    [...] if has_main_town == 0 and 2nd byte below <> 0xFF and (4th uint32 below == 0 or (it's <= 12 and the subsequent string has no NULLs and has length matching that uint32))
      [uint8] starting_hero_is_random
      [uint8] starting_hero_type (never 0xFF; index in HOTRAITS.TXT)
        here and below, editor writes junk to hero type if hero is random
      [uint8] starting_hero_face (0xFF for default)
      [uint32] starting_hero_name_size (0 for default)
      [...] starting_hero_name
    [...] if has_main_town <> 0 and 7th byte below <> 0xFF and (9th uint32 below == 0 or (it's <= ...as above...))
      [uint8] starting_town_create_hero (see note in 2nd)   #only if AB/SoD
      [uint8] starting_town_type (values as in 2nd)          #only if AB/SoD
      [uint8] starting_town_xpos
      [uint8] starting_town_ypos
      [uint8] starting_town_zpos
      [uint8] starting_hero_is_random
      [uint8] starting_hero_type (never 0xFF)
      [uint8] starting_hero_face (0xFF for default)
      [uint32] starting_hero_name_size (0 for default)
      [...] starting_hero_name
    # it's an error if none of the above 4 conditions matched
    [...] additional info   #only if AB/SoD; h3mlib also adds this but it seems invalid: "...and matched either 3rd or 4th conditions above and (is not SoD or (matched 1st condition and town_types <> 0))"
        parse_player_ai.c
      [uint8] count of placeholder heroes (called "unknown1" in h3mlib; h3m.txt: "ilość domostw bohaterów gracza" - "the number of player's heroes' homes")
        likely junk; it has something to do with placeholder heroes on map but it's often 0 when they do exist and it may even get negative (signed): place several placeholder heroes on map and change their type (Power rating vs Specific hero) in various combinations, or do: change hero from Specific to Rating, save, change back to Specific, save, repeat - this field will decrease every time you switch to Specific and save; however, if you restart the editor then this field becomes 0 (even though the placeholder heroes are still there)
      [uint32] heroes_count
      N identical structures, one per hero, N = heroes_count
          includes Visiting heroes and regular hero objects (not random); includes placeholder heroes configured as "Specific hero" rather than "Power rating"; as above, type/name match the object's
        [uint8] type (index in HOTRAITS.TXT)
        [uint32] name_size (0 for default)
        [...] name
[...] additional info      parse_ai.c, h3m_ai.h
  [uint8] win_cond_type (0 acquire artifact, 1 accumulate creatures, 2 accumulate resources, 3 upgrade town, 4 build grail, 5 defeat hero, 6 capture town, 7 defeat monster, 8 flag dwellings, 9 flag mines, 10 transport artifact, 0xFF normal; unknown when introduced exactly, assuming HotA*: 11 defeat all monsters, 12 survive for given time)
  [...] win condition   parse_ai_win_cond.c, h3m_ai_win_cond.h
    [...] ACQUIRE_ARTIFACT info   #only if corresponds to type
      [uint8] allow_normal_win (editor doesn't allow this to be set; possibly ignored by game)
      [uint8] applies_to_computer
      [uint8] type    #only RoE
      [uint16] type    #only AB/SoD
    [...] ACCUMULATE_CREATURES info   #only if corresponds to type
      [uint8] allow_normal_win
      [uint8] applies_to_computer
      [uint8] type (index in CRTRAITS.TXT)     #only RoE
      [uint16] type (index in CRTRAITS.TXT)    #only AB/SoD
      [uint32] count
    [...] ACCUMULATE_RESOURCES info   #only if corresponds to type
      [uint8] allow_normal_win
      [uint8] applies_to_computer
      [uint8] type (0 Wood, 1 Mercury, 2 Ore, 3 Sulfur, 4 Crystal, 5 Gems, 6 Gold)
      [uint32] amount
    [...] POSITION info   #only if build grail/defeat hero/capture town/defeat monster
      [uint8] allow_normal_win (if type == build grail or defeat hero, editor doesn't allow this to be set)
      [uint8] applies_to_computer (if type <> capture town, editor doesn't allow this to be set, sets it implicitly)
      [uint8] xpos (of actionable spot; if type == build grail: if all x/y/zpos == 0xFF means any town)
        in HotA (unknown when introduced exactly, assuming HotA*), monsters are 3x2 (in SoD they are 2x2)
      [uint8] ypos
      [uint8] zpos
    [...] UPGRADE_TOWN info   #only if corresponds to type
      [uint8] allow_normal_win
      [uint8] applies_to_computer (editor doesn't allow this to be set, sets it implicitly)
      [uint8] xpos (of actionable spot; if all x/y/zpos == 0xFF means any town)
      [uint8] ypos
      [uint8] zpos
      [uint8] hall_level (0 Town, 1 City, 2 Capitol)
      [uint8] castle_level (0 Fort, 1 Citadel, 2 Castle)
    [...] FLAG info   #only if flag dwellings/mines
      [uint8] allow_normal_win
      [uint8] applies_to_computer
    [...] TRANSPORT_ARTIFACT info   #only if corresponds to type
      [uint8] allow_normal_win (editor doesn't allow this to be set)
      [uint8] applies_to_computer
      [uint8] type
      [uint8] xpos (of actionable spot)
      [uint8] ypos
      [uint8] zpos
    [...] defeal all monsters info   #only if corresponds to type
      [uint8] allow_normal_win
      [uint8] applies_to_computer (expect off)
    [...] survive for given time info   #only if corresponds to type
      [uint8] allow_normal_win
      [uint8] applies_to_computer (expect off)
      [uint16] days (1-based, win when days + 1 dawns)
  [uint8] lose_cond_type (0 lose town, 1 lose hero, 2 time expires, 0xFF normal)
  [...] lose condition  parse_ai_lose_cond.c, h3m_ai_lose_cond.h
    [...] POSITION info   #only if lose town/hero
      [uint8] xpos
      [uint8] ypos (of actionable spot)
      [uint8] zpos
    [...] TIME info   #only if time expires
      [uint16] days (editor allows 2-6 days, 1-7 weeks or 2-12 months; 1 month has 28 days/4 weeks)
  [uint8] max_team
  N identical structures, one per player, N = 8, in order of basic info   #only if max_team <> 0
      parse_ai_teams.c, h3m_ai_teams.h
    [uint8] team number for player (< max_team)
  [uint32] hero count (expect 179 in v3, else 178), overrides next bitfield's length   #only if HotA*
  16 bytes, each bit = hero availability flag (index in HOTRAITS.TXT)   #only RoE
  20 bytes, each bit = hero availability flag (ditto)   #only AB/SoD
    bits are off for Map Specifications | Heroes and for heroes already placed on map or specified in town Properties | Visiting hero; this seems to be used for Starting Hero in map's Advanced Options when starting a game (further filtered on run-time by hero class vs alignment of Starting Town and removing already picked Starting Heroes by other players; if none remain, only allow Random hero and ignore clicks to left/right arrows around its image)
    editor bug: after unchecking any standard (?) hero in Heroes, bit for "Lord Haart" (HOTRAITS.TXT index 4, line 7) becomes always set even if you recheck it later (but he doesn't appear in Heroes and seems to be generally unused in SoD); this makes it impossible to have all bits off since he cannot be placed on map
  [uint32] count of specific placeholder heroes (called "empty" in h3mlib)    #only AB/SoD
  N identical structures, one per specific hero, N = count above
      not parsed by h3mlib
    [uint8] hero (index in HOTRAITS.TXT)
  [uint8] custom_heroes_count (see heroes below for info)   #only SoD
  N identical structures, one per hero, N = custom_heroes_count   #only SoD
      parse_ai_custom_heroes.c, h3m_ai_custom_hero.h
    [uint8] type
    [uint8] face (0xFF for default)
    [uint32] name_size (0 for default name)
    [...] name
    [uint8] which players can hire (bitfield, 0xFF for all - the default; players not existing on map usually have their bits set)
  31 bytes, reserved (must be all 0s)
  [...] hota extra header   #only if HotA*
      H3MMap.cpp - H3Map::readBinary()
    [uint32] enable special weeks (bool)
    [uint16] unknown (expect 16)
    4 bytes, unknown (should be 0s)
    [uint32] max number of rounds (0xFFFFFFFF, if none)  #only if HotAv3
    [uint32] artifact count (expect 165 in v3, else 163), overrides next bitfield's length
  17 bytes, each bit = artifact *non* availability flag (order in ARTRAITS.TXT)   #only AB
  18 bytes, each bit = artifact *non* availability flag (same)   #only SoD
  9 bytes, each bit = spell *non* availability flag (order in SPTRAITS.TXT)   #only SoD
  4 bytes, each bit = skill *non* availability flag (order in SSTRAITS.TXT)   #only SoD
    the 4 above directly correspond to Map Specifications | Artifacts/Spells/Skills; artifact objects on map do not affect this field; these don't prevent artifacts/spells/skills from being explicitly used via editor (given to hero objects, placed on map, etc.)
    h3mlib erroneously names these as available, not unavailable
  [uint32] rumors_count (editor limits to 30)
  N identical structures, one per rumor, N = rumors_count
      parse_ai_rumor.c, h3m_ai_rumor.h
    [uint32] name_size (editor limits to 30000)
    [...] name
    [uint32] desc_size (editor limits to 300)
    [...] desc
  [uint32] hero count (presumably matches the count written before hero availability flag), overrides the following N   #only if HotA*
  N identical structures, one per hero, N = 156   #only SoD
      parse_ai_hero_settings.c, h3m_ai_hero_settings.h
    [uint8] has_settings
      this and custom heroes override HOTRAITS.TXT/HCTRAITS.TXT fields
      changing any field in Map Specifications | Heroes | Properties sets has_settings, and also creates a "custom" hero if any of Name, Portrait or "May be hired by" is changed
    # below members are not present if has_settings == 0
    [uint8] has_experience
    [uint32] experience (editor allows 1+ since 0 unsets has_experience) #only if has_experience <> 0
    [uint8] has_secondary_skills
    [...] skills #only if has_secondary_skills <> 0
      [uint32] count
      N identical structures, one per skill, N = count
        [uint8] type
        [uint8] level (as elsewhere)
    [uint8] has_artifacts
    [...] artifacts #only if has_artifacts <> 0
      [uint16] headwear (in this section 0xFFFF = default)
      [uint16] shoulders
      [uint16] unknown (neck)
      [uint16] right_hand
      [uint16] left_hand
      [uint16] torso
      [uint16] right_ring
      [uint16] left_ring
      [uint16] feet
      [uint16] misc1
      [uint16] misc2
      [uint16] misc3
      [uint16] misc4
      [uint16] device1 (war machine)
      [uint16] device2
      [uint16] device3
      [uint16] device4 (catapult's slot, not accessible via editor, always empty)
      [uint16] spellbook
      [uint16] misc5
      [uint16] backpack count
      N identical structures, one per artifact, N = backpack count
        [uint16] type
    [uint8] has_biography
    [...] bio #only if has_biography <> 0
      [uint32] bio_size
      [...] bio
    [uint8] gender (0 male, 1 female, 0xFF default)
    [uint8] has_spells
    9 bytes, each bit = spell flag   #only if has_spells <> 0
    [uint8] has_primary_skills
    [...] skills #only if has_primary_skills <> 0
      [uint8] attack_skill
      [uint8] defense_skill
      [uint8] spell_power
      [uint8] knowledge
[...] map tiles (terrains, roads, rivers)   parse_tile.c
  N identical structures, one per each dimension, N = has_two_levels ? 2 : 1
    N identical structures, one per each coord, N = map_size ^ 2
        h3m_tile.h
      [uint8] terrain_type (0 dirt, 1 sand, 2 grass, 3 snow, 4 swamp, 5 rough, 6 subterranean, 7 lava, 8 water, 9 rock; unknown when introduced exactly, assuming HotA*: 10 highland, 11 wasteland)
      [uint8] terrain_sprite (object subclass)
      [uint8] river_type (0 none, 1 clear, 2 icy, 3 muddy, 4 lava)
      [uint8] river_sprite (0-3 corners, 4 +, 5 6 T, 7 8 ├, 9 10 |, 11 12 --)
      [uint8] road_type (0 none, 1 dirt, 2 gravel, 3 cobblestone)
      [uint8] road_sprite (0-5 corners, 6 7 ├, 8 9 T, 10 11 |, 12 13 --, 14 ', 15 -, 16 +)
      [uint8] mirroring (bitfield: horizontal terrain, vertical terrain, horizontal river, vertical river, horizontal road, vertical road, coast, favorable winds (taken from H3MMap.hpp - MapTileH3M.ExtFlags))
        coast is set for non-water tiles adjacent to water tiles, including corners; editor doesn't permit creating a 1-tile lake so the smallest we get is this (. ground, C-oast, ~ water):
        [.][.][.][.][.][.]
        [.][C][C][C][C][.]
        [.][C][~][~][C][.]
        [.][C][~][~][C][.]
        [.][C][C][C][C][.]
        [.][.][.][.][.][.]
[...] object attributes   parse_oa.c, h3m_oa.h, h3m_oa_body.h
  [uint32] count
    at least for the official editor, this array always starts with 2 unused kinds
  N identical structures, one per kind of objects in use, N = count
      object properties are split into two structures: attributes (common for all objects of the same kind, data taken from OBJECTS.TXT/HEROES.TXT) and details (as many as there are objects on map)
    [uint32] def_size
    [...] def
    6 bytes, each bit = passability
    6 bytes, each bit = actionability (may only be set for impassable bits)
      bits of passability and actionability are counted from bottom right corner of a 8*6 tile, with this object placed in bottom right corner of that tile; example for town (a 6*6 object):
      [ ][ ][.][.][.][.][.][.]  p (a) = passability (and actionability) bit set
      [ ][ ][.][.][.][.][.][.]  raw .h3m passability value: FF FF FF 8F 07 07
      [ ][ ][.][.][.][.][.][.]  h3m2json.php passability value:
      [ ][ ][.][.][p][p][p][.]    0_0..0_4 = false, 0_5 = true,
      ^1  1  1  1  0  0  0  1 = 8F
      [ ][ ][.][p][p][p][p][p]    1_0,1_1 = true, 1_2..1_5 = false,
      [ ][ ][.][p][p][a][p][p]    2_0 = false, 2_1..2_4 = true, 3_0..end = false
    [uint16] allowed_landscapes (bitfield: water, lava, underground, rock, swamp, snow, grass, sand, dirt)
    [uint16] landscape_group (bitfield, as allowed_landscapes)
    [uint32] object_class
    [uint32] object_number (object subclass)
    [uint8] object_group (for editor; 0 terrain, 1 town, 2 monster, 3 hero, 4 artifact, 5 treasure)
    [uint8] is ground (if <> 0 then object must always appear below objects with == 0 and also have no shadow; e.g. Gem Pond)
    16 bytes, unknown (should be 0s)
[...] object details      parse_od.c, h3m_od.h
  [uint32] count
  N identical structures, one per object, N = count
    [uint8] x (of bottom right corner)
    [uint8] y
    [uint8] z (0 overground, 1 underground)
      visiting hero is stored as normal object (invisible in editor) with coords matching the town's (this is so despite different town/hero object sizes thanks to object details storing coords of actionable spot, not bottom right corner)
    [uint32] kind (index in object attributes)
    5 bytes, unknown (should be 0s)
    [...] additional info depending on the associated object attributes entry
        parse_oa_meta_type.c, h3m_oa_class.h
      h3mlib determines the info type (oa_type) based on object_class, halting
      if it's unknown (internally equals to oa_type of -1/FF).
      META_OBJECT_GENERIC_IMPASSABLE_TERRAIN
        0 40 114 115 116 117 118 119 120 121 122 123 126 127 128 129 130 131 132
        133 134 135 136 137 138 143 147 148 149 150 151 152 153 154 155 156 157
        158 159 160 161
      META_OBJECT_GENERIC_IMPASSABLE_TERRAIN_ABSOD
        165 166 167 168 169 170 171 172 173 174 177 178 179 180 181 182 183 184
        185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202
        203 204 205 206 207 208 209 210 211
      META_OBJECT_GENERIC_VISITABLE
        2 3 4 7 13 11 14 15 16 22 23 24 25 27 28 30 31 32 35 37 38 39 41
        47 48 49 51 52 55 56 57 58 60 61 64 9 10 78 80 84 85 92 94 95 96
        97 99 100 102 104 105 106 107 108 109 110 111 112 50 1
      META_OBJECT_GENERIC_PASSABLE_TERRAIN_SOD
        222 224 225 226 227 228 229 231 223 230 139 141 142 144 145 146
      META_OBJECT_GENERIC_VISITABLE_ABSOD     221 63 212 213 43 44
      META_OBJECT_ARTIFACT                    5 65 66 67 68 69
      META_OBJECT_ABANDONED_MINE_ABSOD        220
      META_OBJECT_DWELLING                    17 18 19 20
      META_OBJECT_MONOLITH_TWO_WAY            45
        warning: defined in h3m as META_OBJECTMONOLITH_TWO_WAY
      META_OBJECT_DWELLING_ABSOD              XXX not defined in h3m!
      META_OBJECT_TOWN_ABSOD                  XXX not defined in h3m!
      META_OBJECT_MONSTER_ABSOD               XXX not defined in h3m!
      META_OBJECT_ARTIFACT_AB                 XXX not defined in h3m!
      META_OBJECT_ARTIFACT_SOD                XXX not defined in h3m!
      META_OBJECT_EVENT                       26
      META_OBJECT_GARRISON                    33
      META_OBJECT_GARRISON_ABSOD              219
      META_OBJECT_GENERIC_BOAT                8
      META_OBJECT_GENERIC_PASSABLE_TERRAIN    124 21 46 125 176 175
      META_OBJECT_PANDORAS_BOX                6
      META_OBJECT_GRAIL                       36
      META_OBJECT_HERO                        34
      META_OBJECT_LIGHTHOUSE                  42
      META_OBJECT_MONSTER                     54 71 72 73 74 75 162 163 164
      META_OBJECT_OCEAN_BOTTLE                59
      META_OBJECT_PRISON                      62
      META_OBJECT_QUEST_GUARD                 215
      META_OBJECT_RANDOM_DWELLING_ABSOD       216
      META_OBJECT_RANDOM_DWELLING_PRESET_LEVEL_ABSOD      217
      META_OBJECT_RANDOM_DWELLING_PRESET_ALIGNMENT_ABSOD  218
      META_OBJECT_RANDOM_HERO                 70
      META_OBJECT_PLACEHOLDER_HERO            214
      META_OBJECT_RESOURCE                    79 76
      META_OBJECT_RESOURCE_GENERATOR          53
      META_OBJECT_SCHOLAR                     81
      META_OBJECT_SEERS_HUT                   83
      META_OBJECT_SHIPYARD                    87
      META_OBJECT_SHRINE                      88 89 90
      META_OBJECT_SIGN                        91
      META_OBJECT_SPELL_SCROLL                93
      META_OBJECT_SUBTERRANEAN_GATE           103
      META_OBJECT_TOWN                        98 77
      META_OBJECT_WITCH_HUT                   113
      META_OBJECT_GENERIC_TREASURE            12 29 82 86 101
      #if META_OBJECT_PLACEHOLDER_HERO      parse_od.c
        [uint8] owner
        [uint8] type
        [uint8] power_rating    #only if type == 0xFF
      #if META_OBJECT_QUEST_GUARD     parse_od_quest_guard.c
      #or, unknown when introduced exactly, assuming HotA*: if class 212 and subclass 1000
        [uint8] quest_type (0 none, 1 level, 2 primary skills, 3 defeat hero, 4 defeat monster, 5 artifacts, 6 creatures, 7 resources, 8 be hero, 9 be player; unknown when introduced exactly, assuming HotA*: 10 be hero class or after date)
        [...] quest info      parse_od_ext_quest.c
          [uint32] level (1-based) #if level
            h3mlib erroneously names this "experience"
          [...] skills #if primary skills
            [uint8] attack_skill
            [uint8] defense_skill
            [uint8] spell_power
            [uint8] knowledge
          [uint32] absod_id #if defeat hero or defeat monster
            everywhere in this memo, absod_id stands for a unique number used to locate map objects targeted by Quest Guard and Random Dwelling; for example, for defeat monster it may be 323232432, and there will be exactly one META_OBJECT_MONSTER_ABSOD object with same 323232432 absod_id; objects not targeted by Quest Guard will still have a unique absod_id but it won't appear anywhere else
          N uint32, one per each resource, N = 7 #if resources
          [uint8] hero (index in HOTRAITS.TXT) #if be hero
          [uint8] player (0-7) #if be player
          [...] creatures #if creatures
            [uint8] count
            N identical structures, one per creature, N = count
              [uint16] type (0xFFFF - no creature; index in CRTRAITS.TXT)
              [uint16] count
          [...] artifacts #if artifacts
            [uint8] count
            N identical structures, one per artifact, N = count
              [uint16] type (index in ARTRAITS.TXT)
          [...] hota quests #if 10
            [uint32] subtype (0 be hero class, 1 after date)
            [...] be hero class quest   #if subtype = 0
              [uint32] count (expect 20)
              [...] required hero classes (bitfield, length = ceil(count / 8))
                knight cleric ranger druid alchemist wizard demoniac heretic deathKnight necromancer overlord warlock barbarian battleMage beastmaster witch planeswalker elementalist captain navigator
            [uint32] after date (0-based)   #if subtype = 1
          [...] deadline info #only if quest_type <> 0
            [uint32] deadline (0-based, 0 = stop passing on Day 1, i.e. will never allow anybody; 0xFFFFFFFF if none; h3mlib mistakenly reads this even if quest_type is 0)
              h3mlib erroneously reads this always, even if quest_type is 0
            [uint32] first encounter message size (use default if 0)
            [...] first encounter message
            [uint32] subsequent encounter unfulfilled message size
            [...] subsequent encounter unfulfilled message
            [uint32] fulfilled message size
            [...] fulfilled message
      #if META_OBJECT_PANDORAS_BOX     parse_od_pandoras_box.c
        [uint8] has_guardians
        [...] guardians #only if has_guardians <> 0
            parse_od_ext_guardians.c
          [uint32] mesg_size (editor limits to 30000)
          [...] mesg
          [uint8] has_creatures
          [...] creatures #if has_creatures <> 0
            N identical structures, one per creature, N = 7
              [uint8] type (0xFF - no creature)   #only RoE
              [uint16] type (0xFFFF - no creature)   #only AB/SoD
              [uint16] count
          4 bytes, unknown
        [...] contents of the box   parse_od_ext_contents.c
          [uint32] experience
          [int32] spell_points (can be negative, max 999)
          [int8] morale (can be negative)
          [int8] luck (can be negative)
          N int32, one per each resource, N = 7 (can be negative)
          [...] skills
            [uint8] attack_skill
            [uint8] defense_skill
            [uint8] spell_power
            [uint8] knowledge
          [uint8] secondary_skills_count (max 8)
          N identical structures, one per skill, N = secondary_skills_count
            [uint8] type
            [uint8] level (as elsewhere)
          [uint8] artifacts_count
          N identical structures, one per artifact, N = artifacts_count
            [uint8] type (index in ARTRAITS.TXT)  #only RoE
            [uint16] type (index in ARTRAITS.TXT) #only AB/SoD
          [uint8] spells_count
          N identical structures, one per spell, N = spells_count
            [uint8] type (index in SPTRAITS.TXT)
          [uint8] creatures_count
          N identical structures, one per creature, N = creatures_count
            [uint8] type (0xFF - no creature)   #only RoE
            [uint16] type (0xFFFF - no creature)   #only AB/SoD
            [uint16] count (max 9999)
          8 bytes, unknown (should be 0s)
      #if META_OBJECT_SIGN or META_OBJECT_OCEAN_BOTTLE     parse_od_message_bearer.c
        [uint32] mesg_size (show random default if 0)
        [...] mesg
        4 bytes, unknown (should be 0s)
      #if META_OBJECT_GARRISON or META_OBJECT_GARRISON_ABSOD    parse_od.c
        [uint32] owner (0xFF none)
        N identical structures, one per creature, N = 7
          [uint8] type (0xFF - no creature)   #only RoE
          [uint16] type (0xFF - no creature)   #only AB/SoD
          [uint16] count
        [uint8] can remove units (if not, hero can add new creatures to garrison but can't take them, even earlier given ones)  #only AB/SoD (true in RoE)
        8 bytes, unknown
      #if META_OBJECT_EVENT     parse_od_event.c
        [...] as in META_OBJECT_PANDORAS_BOX
        [uint8] affected players (bitfield)
        [uint8] applies_to_computer
        [uint8] remove event after first visit
        4 bytes, unknown (should be 0s)
        [uint8] applies_to_human    #if HotAv3
      #if META_OBJECT_GRAIL    parse_od.c
        [uint32] allowable_radius (editor limits to 0-127)
      #if META_OBJECT_DWELLING, META_OBJECT_DWELLING_ABSOD, META_OBJECT_LIGHTHOUSE, META_OBJECT_RESOURCE_GENERATOR, META_OBJECT_SHIPYARD
        [uint32] owner (0xFF none)
      #if META_OBJECT_ABANDONED_MINE_ABSOD
        [uint32] potential (bitfield: LSB wood that is forced off by editor, then mercury, ore, sulfur, crystal, gems, MSB gold; editor doesn't allow empty list)
          h3mlib erroneously reads META_OBJECT_ABANDONED_MINE_ABSOD as META_OBJECT_RESOURCE_GENERATOR, with owner instead of potential
      #if META_OBJECT_GENERIC_BOAT or META_OBJECT_GENERIC_PASSABLE_TERRAIN or META_OBJECT_GENERIC_PASSABLE_TERRAIN_SOD or META_OBJECT_GENERIC_IMPASSABLE_TERRAIN or META_OBJECT_GENERIC_IMPASSABLE_TERRAIN_ABSOD or META_OBJECT_GENERIC_VISITABLE or META_OBJECT_GENERIC_VISITABLE_ABSOD or META_OBJECT_GENERIC_TREASURE or META_OBJECT_MONOLITH_TWO_WAY or META_OBJECT_SUBTERRANEAN_GATE
        no additional info for such objects (16 24 25 84 85 are different for HotA, see below)
      #if META_OBJECT_TOWN or META_OBJECT_TOWN_ABSOD    parse_od_town.c
        [uint32] absod_id   #only AB/SoD
        [uint8] owner (0xFF none)
        [uint8] has_name
        [uint32] name_size    #only if has_name <> 0
        [...] name            #only if has_name <> 0
        [uint8] has_creatures
        N identical structures, one per creature, N = 7   #only if has_creatures <> 0
          [uint8] type (0xFF - no creature)   #only RoE
          [uint16] type (0xFFFF - no creature)   #only AB/SoD
          [uint16] count
        [uint8] formation (as elsewhere)
        [uint8] has_buildings
        [...] buildings #only if has_buildings <> 0
          6 bytes, each bit = is built (Hall is not included here, it's always assumed to be built in absence of other halls; unupgraded buildings are included: dwelling# + dwelling#U, mageGuild1 ... up to #, etc.; required are included too: lookoutTower + fort + citadel + castle):
            [Byte 1]
              townHall
              cityHall
              capitol
              fort
              citadel
              castle
              tavern
              blacksmith
            [Byte 2]
              marketplace
              resourceSiloWO | resourceSiloC | resourceSiloJ | resourceSiloM | resourceSiloS
              artifactMerchants
              mageGuild1
              mageGuild2
              mageGuild3
              mageGuild4
              mageGuild5
            [Byte 3]
              shipyard
              grail | colossus | spiritGuardian | skyship | deityOfFire | soulPrison | guardianOfEarth | warlordMonument | carnivorousPlant | auroraBorealis
              lighthouse | mysticPond | library | brimstoneStormclouds | coverOfDarkness | manaVortex | escapeTunnel | cageOfWarlords | magicUniversity
              brotherhoodOfSword | fountainOfFortune | wallOfKnowledge | castleGate | necromancyAmplifier | portalOfSummoning | freelancerGuild | glyphsOfFear
              stables | treasury | lookoutTower | orderOfFire | skeletonTransformer | battleScholarAcademy | ballistaYard | bloodObelisk
              hallOfValhalla
              dwelling1 | guardhouse | centaurStables | workshop | impCrucible | cursedTemple | warren | goblinBarracks | gnollHut | magicLantern
              dwelling1U | guardhouseU | centaurStablesU | workshopU | impCrucibleU | cursedTempleU | warrenU | goblinBarracksU | gnollHutU | magicLanternU
            [Byte 4]
              horde1 | birthingPools | unearthedGraves | mushroomRings | messHall | captainQuarters | gardenOfLife
              dwelling2 | archerTower | dwarfCottage | parapet | hallOfSins | graveyard | harpyLoft | wolfPen | lizardDen | altarOfAir
              dwelling2U | archerTowerU | dwarfCottageU | parapetU | hallOfSinsU | graveyardU | harpyLoftU | wolfPenU | lizardDenU | altarOfAirU
              horde2 | minerGuild | sculptorWings
              dwelling3 | griffinTower | homestead | golemFactory | kennels | tombOfSouls | pillarOfEyes | orcTower | serpentFlyHive | altarOfWater
              dwelling3U | griffinTowerU | homesteadU | golemFactoryU | kennelsU | tombOfSoulsU | pillarOfEyesU | orcTowerU | serpentFlyHiveU | altarOfWaterU
              horde3 | cages | griffinBastion
              dwelling4 | barracks | enchantedSpring | mageTower | demonGate | estate | chapelOfStilledVoices | ogreFort | basiliskPit | altarOfFire
            [Byte 5]
              dwelling4U | barracksU | enchantedSpringU | mageTowerU | demonGateU | estateU | chapelOfStilledVoicesU | ogreFortU | basiliskPitU | altarOfFireU
              horde4
              dwelling5 | monastery | dendroidArches | altarOfWishes | hellHole | mausoleum | labyrinth | cliffNest | gorgonLair | altarOfEarth
              dwelling5U | monasteryU | dendroidArchesU | altarOfWishesU | hellHoleU | mausoleumU | labyrinthU | cliffNestU | gorgonLairU | altarOfEarthU
              horde5 | dendroidSaplings
              dwelling6 | trainingGrounds | unicornGlade | goldenPavilion | fireLake | hallOfDarkness | manticoreLair | cyclopCave | wyvernNest | altarOfThought
              dwelling6U | trainingGroundsU | unicornGladeU | goldenPavilionU | fireLakeU | hallOfDarknessU | manticoreLairU | cyclopCaveU | wyvernNestU | altarOfThoughtU
              dwelling7 | portalOfGlory | dragonCliffs | cloudTemple | forsakenPalace | dragonVault | dragonCave | behemothLair | hydraPond | pyre
            [Byte 6]
              dwelling7U | portalOfGloryU | dragonCliffsU | cloudTempleU | forsakenPalaceU | dragonVaultU | dragonCaveU | behemothLairU | hydraPondU | pyreU
          6 bytes, each bit = is disabled; order as above (neither upgraded nor depending buildings are included)
        [uint8] has_fort  #only if has_buildings == 0
        9 bytes, each bit = must have spell (index in SPTRAITS.TXT)   #only AB/SoD
        9 bytes, each bit = may *not* have spell (index in SPTRAITS.TXT)
          h3mlib erroneously names this as may-have, not may-not
        [uint8] allow spell research (bool)   #if HotA*
        [uint32] event_count
        N identical structures, one per event, N = event_count
          [uint32] name_size
          [...] name
          [uint32] mesg_size
          [...] mesg
          N int32, one per each resource, N = 7 (can be negative)
          [uint8] affected players (bitfield)
          [uint8] applies_to_human    #only SoD
          [uint8] applies_to_computer (even if set, event is never triggered if town is unowned)
          [uint16] days until first occurence (max 671)
          [uint8] repeat after days (0 don't; max 28)
          17 bytes, unknown (should be 0s)
          6 bytes, each bit = building (as in buildings above, unupgraded included)
          N uint16, one per each extra creature growth (dwelling level), N = 7
          4 bytes, unknown
        [uint8] alignment (always 0xFF for regular town; for random town with checked "Same as Owner or Random" is 0xFF, else is 0-7 - "Same as Player N"; controlled by editor's Town Properties | General | "Alignment" list; unknown when introduced exactly, assuming HotA*: 8-15 - "Different from Player N") #only SoD
        3 bytes, unknown (should be 0s)
      #if META_OBJECT_RANDOM_DWELLING_ABSOD or META_OBJECT_RANDOM_DWELLING_PRESET_ALIGNMENT_ABSOD or META_OBJECT_RANDOM_DWELLING_PRESET_LEVEL_ABSOD
          parse_od_random_dwelling.c
        [uint32] owner (0xFF none)
        [uint32] castle_absod_id (target town; editor's Alignment | "Same as")    #only if META_OBJECT_RANDOM_DWELLING_ABSOD or META_OBJECT_RANDOM_DWELLING_PRESET_LEVEL_ABSOD
        2 bytes, each bit = alignment (editor's Alignment | "Select one of")   #only if castle_absod_id is present and == 0
        [uint8] min_level (0-based) #only if META_OBJECT_RANDOM_DWELLING_ABSOD or META_OBJECT_RANDOM_DWELLING_PRESET_ALIGNMENT_ABSOD
        [uint8] max_level (0-based) #only if META_OBJECT_RANDOM_DWELLING_ABSOD or META_OBJECT_RANDOM_DWELLING_PRESET_ALIGNMENT_ABSOD
      #if META_OBJECT_HERO or META_OBJECT_RANDOM_HERO or META_OBJECT_PRISON
          parse_od_hero.c
        [uint32] absod_id   #only AB/SoD
        [uint8] owner (always 0xFF for META_OBJECT_PRISON)
        [uint8] type (index in HOTRAITS.TXT, 0xFF if random)
        [uint8] has_name
        [uint32] name_size (editor limits to 12)    #only if has_name <> 0
        [...] name            #only if has_name <> 0
        [uint8] has_experience  #only SoD
        [uint32] experience   #only if RoE/AB or has_experience is <> 0
        [uint8] has_face
        [uint8] face  #only if has_face <> 0
        [uint8] has_secondary_skills
        [...] skills  #only if has_secondary_skills <> 0
          [uint32] count
          N identical structures, one per skill, N = count
            [uint8] type
            [uint8] level (as elsewhere)
        [uint8] has_creatures
        N identical structures, one per creature, N = 7   #only if has_creatures <> 0
          [uint8] type (0xFF - no creature)   #only RoE
          [uint16] type (0xFFFF - no creature)   #only AB/SoD
          [uint16] count
        [uint8] formation (0 Spread, 1 Grouped)
        [uint8] has_artifacts
        [...] artifacts #only if has_artifacts <> 0
          # below, uint8 for RoE, uint16 for AB/SoD
          [uint8/16] headwear (in this section 0xFF (RoE)/0xFFFF (AB+) = default)
          [uint8/16] shoulders
          [uint8/16] unknown (neck)
          [uint8/16] right_hand
          [uint8/16] left_hand
          [uint8/16] torso
          [uint8/16] right_ring
          [uint8/16] left_ring
          [uint8/16] feet
          [uint8/16] misc1
          [uint8/16] misc2
          [uint8/16] misc3
          [uint8/16] misc4
          [uint8/16] device1 (war machine)
          [uint8/16] device2
          [uint8/16] device3
          [uint8/16] device4 (see above for this slot)
          [uint8/16] spellbook
          [uint8/16] misc5    #only SoD
          [uint16] backpack count
          N identical structures, one per artifact, N = backpack count
            [uint8/16] type
        [uint8] patrol_radius (default 0xFF for no patrol)
        [uint8] has_biography   #only AB/SoD
        [uint32] bio_size   #only if has_biography <> 0
        [...] bio           #only if has_biography <> 0
        [uint8] gender (as elsewhere)    #only AB/SoD
        [uint8] has_spells    #only SoD
        9 bytes, each = spell   #only if has_spells <> 0
        [uint8] spell   #only AB
        [uint8] has_primary_skills  #only SoD
        [...] #only if has_primary_skills <> 0
          [uint8] attack_skill
          [uint8] defense_skill
          [uint8] spell_power
          [uint8] knowledge
        16 bytes, unknown (default 0s)
      #if META_OBJECT_MONSTER or META_OBJECT_MONSTER_ABSOD    parse_od_monster.c
        [uint32] absod_id   #only AB/SoD
        [uint16] count (0 random)
        [uint8] disposition (likelyhood of joining hero; h3m_disposition.h: 0 compliant, 1 friendly, 2 aggressive, 3 hostile, 4 savage)
        [uint8] has_mesg_and_treasure
        [...] treasure  #only if has_mesg_and_treasure <> 0
          [uint32] mesg_size
          [...] mesg
          N uint32, one per each resource, N = 7
          [uint8] artifact (0xFF none)  #only RoE
          [uint16] artifact (0xFFFF none)  #only AB/SoD
        [uint8] never_flees
        [uint8] does_not_grow
        2 bytes, unknown (should be 0s)
        [...] hota monster info   #if HotAv3
            H3MObjects.cpp - MapMonster::readBinary()
          [uint32] exact aggression (or 0xFFFFFFFF)
          [uint8] join only for money (bool)
          [uint32] join percentage
          [uint32] upgraded stack (or 0xFFFFFFFF)
          [uint32] split stack (or 0xFFFFFFFF)
      #if META_OBJECT_ARTIFACT or META_OBJECT_ARTIFACT_AB or META_OBJECT_ARTIFACT_SOD    parse_od_artifact.c
        [uint8] has_guardians
        [...] guardians as in META_OBJECT_PANDORAS_BOX #only if has_guardians <> 0
      #if META_OBJECT_SHRINE    parse_od.c
        [uint32] spell (0xFF random)
      #if META_OBJECT_SPELL_SCROLL    parse_od_spell_scroll.c
        [...] as in META_OBJECT_ARTIFACT
        [uint32] spell
      #if META_OBJECT_RESOURCE    parse_od_resource.c
        [...] as in META_OBJECT_ARTIFACT
        [uint32] quantity (multiply by 100 for gold, i.e. subclass 6)
        4 bytes, unknown
      #if META_OBJECT_WITCH_HUT    parse_od.c
        4 bytes, each bit = skill potentiability (order in SSTRAITS.TXT; editor doesn't allow empty list)   #only AB/SoD
          in RoE, this is hardcoded to all but Leadership/Necromancy enabled, which default to off in AB+ but may be changed
      #if META_OBJECT_SEERS_HUT    #if HotAv3
        [uint32] one-time quest count
        [...] not tested but likely N identical structures of non-HotA META_OBJECT_SEERS_HUT below, one per quest
        [uint32] recurring quest count
        [...] as above
      #if META_OBJECT_SEERS_HUT    parse_od_seers_hut.c   #if not HotAv3
        [uint8] artifact_type (0xFF none)  #only RoE
        [...] contents of META_OBJECT_QUEST_GUARD  #only AB/SoD
        [uint8] reward_type (0 none, 1 experience, 2 spell points, 3 morale, 4 luck, 5 resource, 6 primary skill, 7 secondary skill, 8 artifact, 9 spell, 10 creature)
        [...] reward info     #only if reward_type <> none
          h3mlib doesn't have this parsed as of now; only structure size is
          determined: 0, 4, 4, 1, 1, 5, 2, 2, RoE ? 1 : 2, 1, RoE ? 3 : 4
          According to h3m.txt (doesn't provide RoE/AB/SoD support info):
            [uint32] experience   #only if corresponds to reward_type
            [uint32] spell points   #only if corresponds to reward_type
            [uint8] morale (1 +1, 2 +2, 3 +3)   #only if corresponds to reward_type
            [uint8] luck (same)   #only if corresponds to reward_type
            [...] resource   #only if corresponds to reward_type
              [uint8] resource type (as elsewhere)
              [uint32] amount (max 99999)
            [...] primary skill   #only if corresponds to reward_type
              [uint8] skill type (0 attack, 1 defense, 2 spell power, 3 knowledge)
              [uint8] value (max 99)
            [...] secondary skill   #only if corresponds to reward_type
              [uint8] skill type (index in SSTRAITS.TXT)
              [uint8] level (as elsewhere)
            [...] artifact   #only if corresponds to reward_type
              [uint8] type (index in ARTRAITS.TXT)  #only RoE
              [uint16] type (index in ARTRAITS.TXT) #only AB/SoD
            [uint8] spell   #only if corresponds to reward_type
            [...] creature   #only if corresponds to reward_type
              [uint8] type (index in CRTRAITS.TXT)   #only RoE
              [uint16] type (index in CRTRAITS.TXT)   #only AB/SoD
              [uint16] count (max 9999)
        2 bytes, unknown
      #if META_OBJECT_SCHOLAR    parse_od.c
        [uint8] reward_type (0xFF random, 0 primary skill, 1 secondary skill, 2 spell)
        [uint8] reward_value (always 0 if type is random; 0 boost attack/1 defense/2 spell power/3 knowledge; index in SSTRAITS.TXT; index in SPTRAITS.TXT)
        6 bytes, unknown
      #if creature bank (classes: 16 24 25 84 85) and HotAv3
          H3MObjects.cpp - MapObjectCreatureBank::readBinary()
        [uint32] content (or 0xFFFFFFFF)
        [uint8] upgraded (0/1 if bool, 0xFF if unset)
        [uint32] artifacts_count
        N identical structures, one per artifact, N = artifacts_count
          [uint32] type (index in ARTRAITS.TXT)
[...] global events       parse_event.c, h3m_event.h, h3m_event_body.h
  [uint32] count
  N identical structures, one per event, N = count
    [uint32] name_size
    [...] name
    [uint32] mesg_size
    [...] mesg
    N int32, one per each resource, N = 7 (max 32767, can be negative)
    [uint8] affected players (bitfield)
    [uint8] applies_to_human    #only SoD (true before)
    [uint8] applies_to_computer
    [uint16] days until first occurence (0-based, 0 = Day 1; max 671)
    [uint8] repeat after days (0 don't; max 28)
    17 bytes, unknown (should be 0s)
[...] 124 bytes, padding (should be 0s)   #only if not HDE (HD Edition)
